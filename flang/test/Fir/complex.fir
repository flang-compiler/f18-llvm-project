// RUN: %CC -c %S/print_complex.c
// RUN: tco --target=x86_64-unknown-linux-gnu %s | FileCheck %s --check-prefix=LLVMIR
// RUN: tco --target=x86_64-unknown-linux-gnu %s | llc --filetype=obj -o %t
// RUN: %CC %t print_complex.o
// RUN: ./a.out | FileCheck %s --check-prefix=EXECHECK

// REQUIRES: x86-registered-target
// UNSUPPORTED: darwin, macos

// EXECHECK: <0.935893, 2.252526>

// LLVMIR-LABEL: define <2 x float> @foo(<2 x float> %
func @foo(%a : !fir.complex<4>, %b : !fir.complex<4>, %c : !fir.complex<4>, %d : !fir.complex<4>, %e : !fir.complex<4>) -> !fir.complex<4> {
  // LLVMIR-COUNT-2: extractvalue
  // LLVMIR: fadd float
  // LLVMIR-COUNT-2: extractvalue
  // LLVMIR: fadd float
  // LLVMIR-COUNT-2: insertvalue
  %1 = fir.addc %a, %b : !fir.complex<4>
  // LLVMIR: fmul float
  %2 = fir.mulc %1, %c : !fir.complex<4>
  // LLVMIR: fsub float
  %3 = fir.subc %2, %d : !fir.complex<4>
  // LLVMIR: fdiv float
  %4 = fir.divc %3, %e : !fir.complex<4>
  return %4 : !fir.complex<4>
}

// LLVMIR-LABEL: define float @real_part(<2 x float> %0)
func @real_part(%a : !fir.complex<4>) -> f32 {
  %0 = arith.constant 0 : i32
  // LLVMIR: extractvalue
  %1 = fir.extract_value %a, [0 : i32] : (!fir.complex<4>) -> f32
  return %1 : f32
}

// LLVMIR-LABEL: define <2 x float> @conj(<2 x float> %
func @conj(%a : !fir.complex<4>) -> !fir.complex<4> {
  %0 = arith.constant 1 : i32
  // LLVMIR: extractvalue
  %1 = fir.extract_value %a, [1 : i32] : (!fir.complex<4>) -> f32
  // LLVMIR: fneg float
  %2 = arith.negf %1 : f32
  // LLVMIR: insertvalue
  %3 = fir.insert_value %a, %2, [1 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  return %3 : !fir.complex<4>
}

// LLVMIR-LABEL: @issue846
func @issue846(%z : !fir.complex<4>) -> !fir.complex<8> {
  // Verify that addc rewrite is not disturbing fir.convert rewrite.
  // LLVMIR-COUNT-2: fadd
  %add = fir.addc %z, %z : !fir.complex<4>
  // LLVMIR-COUNT-2: fpext
  %cast = fir.convert %add : (!fir.complex<4>) -> !fir.complex<8>
  return %cast : !fir.complex<8>
}

func private @print_complex(f32, f32)

func @main() -> i32 {
  %0 = fir.alloca !fir.complex<4>
  %1 = fir.alloca !fir.complex<4>
  %2 = fir.alloca !fir.complex<4>
  %3 = fir.alloca !fir.complex<4>
  %4 = fir.alloca !fir.complex<4>

  %5 = fir.undefined !fir.complex<4>
  %c0 = arith.constant 0 : i32
  %c1 = arith.constant 1 : i32

  %f0 = arith.constant 4.0 : f32
  %f1 = arith.constant 52.5 : f32
  %6 = fir.insert_value %5, %f0, [0 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  %7 = fir.insert_value %6, %f1, [1 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  fir.store %7 to %0 : !fir.ref<!fir.complex<4>>

  %8 = fir.load %0 : !fir.ref<!fir.complex<4>>
  %9 = fir.call @conj(%8) : (!fir.complex<4>) -> !fir.complex<4>
  fir.store %9 to %1 : !fir.ref<!fir.complex<4>>

  %a0 = arith.constant 95.65 : f32
  %a1 = arith.constant 234.1 : f32
  %a2 = fir.insert_value %5, %a0, [0 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  %a3 = fir.insert_value %a2, %a1, [1 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  fir.store %a3 to %2 : !fir.ref<!fir.complex<4>>

  %b0 = arith.constant 33.0 : f32
  %b1 = arith.constant 87.69 : f32
  %b2 = fir.insert_value %5, %b0, [0 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  %b3 = fir.insert_value %b2, %b1, [1 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  fir.store %b3 to %3 : !fir.ref<!fir.complex<4>>

  %d0 = arith.constant 791.0 : f32
  %d1 = arith.constant 3.5923 : f32
  %d2 = fir.insert_value %5, %d0, [0 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  %d3 = fir.insert_value %d2, %d1, [1 : i32] : (!fir.complex<4>, f32) -> !fir.complex<4>
  fir.store %d3 to %4 : !fir.ref<!fir.complex<4>>

  %l0 = fir.load %0 : !fir.ref<!fir.complex<4>>
  %l1 = fir.load %1 : !fir.ref<!fir.complex<4>>
  %l2 = fir.load %2 : !fir.ref<!fir.complex<4>>
  %l3 = fir.load %3 : !fir.ref<!fir.complex<4>>
  %l4 = fir.load %4 : !fir.ref<!fir.complex<4>>

  %10 = fir.call @foo(%l0, %l1, %l2, %l3, %l4) : (!fir.complex<4>, !fir.complex<4>, !fir.complex<4>, !fir.complex<4>, !fir.complex<4>) -> !fir.complex<4>
  %11 = fir.extract_value %10, [0 : i32] : (!fir.complex<4>) -> f32
  %12 = fir.extract_value %10, [1 : i32] : (!fir.complex<4>) -> f32
  fir.call @print_complex(%11, %12) : (f32, f32) -> ()
  return %c0 : i32
}
